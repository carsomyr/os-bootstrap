#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
#
# Copyright 2014-2017 Roy Liu
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

require "digest"
require "etc"
require "fileutils"
require "json"
require "optparse"
require "pathname"
require "rake"
require "rbconfig"
require "rexml/document"
require "shellwords"
require "yaml"

module OsX
  module Bootstrap
    # A formatter for framed, line-wrapped messages.
    class Formatter
      def initialize(header, footer, line_header, line_footer = nil, line_max = nil)
        @header = header
        @footer = footer
        @line_header = line_header
        @line_footer = line_footer
        @line_max = line_max
      end

      # Formats the given string: Wraps lines to under the line size limit while applying headers and footers.
      def format(str)
        acc = ""

        acc = @header + "\n" \
          if @header

        single_space_pattern = Regexp.new(" ")
        line_acc = nil

        REXML::Document.new("<root>#{str}</root>").root.children.each do |node|
          case node
            when REXML::Text
              first_line = true

              node.value.split("\n", -1).each do |line|
                if !first_line
                  acc += emit_line(line_acc || "")
                  line_acc = nil
                end

                first_word = true

                # Apparently the string `" "` has special meaning for Ruby regular expressions, so we use a regex to
                # force the issue.
                line.split(single_space_pattern, -1).each do |word|
                  if line_acc
                    if !first_word
                      sep = " "
                    else
                      sep = ""
                    end

                    if @line_max && line_acc.size + sep.size + word.size > @line_max
                      # Emit the accumulator and move on to building the next line.
                      acc += emit_line(line_acc)
                    else
                      # Accumulate the word.
                      line_acc += sep + word
                      first_word = false

                      next
                    end
                  end

                  # Trim the word down to size.
                  while @line_max && word.size > @line_max
                    acc += emit_line(word[0...(@line_max - 1)] + "-")
                    word = word[(@line_max - 1)...(word.size)]
                  end

                  line_acc = word
                  first_word = false
                end

                first_line = false
              end
            when REXML::Element
              case node.name
                when "nobreak"
                  first_line = true

                  (node.text || "").split("\n", -1).each do |line|
                    if !first_line
                      acc += emit_line(line_acc || "")
                      line_acc = nil
                    end

                    if line_acc
                      if @line_max && line_acc.size + line.size > @line_max
                        # Emit the accumulator and move on to building the next line.
                        acc += emit_line(line_acc)
                      else
                        # Accumulate the line.
                        line_acc += line
                        first_line = false

                        next
                      end
                    end

                    # Trim the line down to size.
                    while @line_max && line.size > @line_max
                      acc += emit_line(line[0...(@line_max - 1)] + "-")
                      line = line[(@line_max - 1)...(line.size)]
                    end

                    line_acc = line
                    first_line = false
                  end
                else
                  raise "Invalid node name #{node.name.dump}"
              end
            else
              raise "Invalid node class #{node.class.name.dump}"
          end
        end

        acc += emit_line(line_acc) \
          if line_acc

        acc += @footer + "\n" \
          if @footer

        acc
      end

      private

      # Emits a single line of output.
      def emit_line(word)
        if @line_max
          @line_header + word + " " * (@line_max - word.size) + @line_footer + "\n"
        else
          @line_header + word + "\n"
        end
      end
    end

    # Some helpers to reduce boilerplate in Rake tasks.
    module RakeHelpers
      module InstanceMethods
        # Runs the given block as a particular user and group.
        def as_user(user = ENV["SUDO_USER"], group = nil, &block)
          _, exit_status = Process.waitpid2(fork do
            Process.gid = Process.egid = Etc.getgrnam(group).gid \
              if group

            Process.uid = Process.euid = Etc.getpwnam(user).uid \
              if user

            block.call

            exit!(0)
          end)

          raise RuntimeError, "Child process exited with nonzero status" \
            if exit_status != 0
        end

        # Normalize the given target-dependency specification.
        def normalize_target_deps(target_deps)
          if target_deps.is_a?(Hash)
            raise ArgumentError, "Invalid target-dependency specification" \
              if target_deps.size != 1

            target, deps = target_deps.each_pair.first
          else
            target, deps = target_deps, []
          end

          deps = [deps] \
            if !deps.is_a?(Array)

          [target, deps]
        end

        # Creates a writeable directory along with any missing parent directories.
        def writeable_directory(target_deps)
          target, deps = normalize_target_deps(target_deps)

          return nil \
            if target.directory? || Rake::Task.task_defined?(target.to_s)

          raise "Target must be a directory" \
            if target.exist?

          parent_task = writeable_directory target.parent => deps

          if parent_task
            task_deps = deps + [parent_task]
          else
            task_deps = deps
          end

          directory target.to_s => task_deps do
            as_user("root") do
              mkdir target

              # Set group writeability and ownership to the `admin` group, which the user is presumed to be a member of.
              chmod 0775, target
              chown nil, "admin", target
            end
          end
        end

        # Creates a file along with any missing parent directories.
        def with_parent_directory(target_deps, &block)
          target, deps = normalize_target_deps(target_deps)

          parent_task = writeable_directory target.parent => deps

          if parent_task
            task_deps = deps + [parent_task]
          else
            task_deps = deps
          end

          file target => task_deps, &block
        end

        # Installs the command-line tools package via the `softwareupdate` tool.
        def softwareupdate_install
          # Ensures that the magic file for faking an on-demand installation is in place. See
          # `http://macops.ca/installing-command-line-tools-automatically-on-mavericks/`.
          magic_temp_file = Pathname.new("/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress")

          pp(:info, "Run `softwareupdate` to get the manifest of available updates")

          touch magic_temp_file

          begin
            sh "softwareupdate", "-l"

            node = nil

            (0...6).each do |backoff|
              begin
                # After `softwareupdate` has run, look in the plist of recommended updates. Some sort of command-line
                # tools package should be there.

                xml = IO.popen(["plutil", "-convert", "xml1", "-o", "-", "--",
                                "/Library/Preferences/com.apple.SoftwareUpdate.plist"]) do |io|
                  io.read
                end

                exit_status = $?.exitstatus

                raise "`plutil` returned nonzero exit status #{exit_status}" \
                  if exit_status != 0

                # Create an XPath query for the package information.
                doc = REXML::Document.new(xml)
                node = doc.elements["/plist" \
                    "/dict" \
                    "/key[text()=\"RecommendedUpdates\"]" \
                    "/following::array[position()=1]" \
                    "/dict[key[text()=\"Display Name\"]" \
                    "/following::string[position()=1 and starts-with(text(), \"Command Line \")]]"
                ]
              rescue ArgumentError, SystemCallError, REXML::ParseException
                node = nil
              end

              # Use an exponential backoff mechanism to account for the `softwareupdate` not writing to
              # `/Library/Preferences/com.apple.SoftwareUpdate.plist`: That responsibility belongs to something else,
              # probably a daemon.
              if node
                break
              else
                delay = 2 ** backoff

                pp(:info, "Command-line tools package metadata not found: retrying in #{delay} seconds")

                sleep delay
              end
            end

            raise "Could not find the necessary metadata for installing the command-line tools package" \
              if !node

            identifier = node.elements["key[text()=\"Identifier\"]/following::string[position()=1]/text()"]
            display_version = node.elements["key[text()=\"Display Version\"]/following::string[position()=1]/text()"]

            pp(:info, "Install #{identifier} via `softwareupdate`")

            sh "softwareupdate", "-i", "#{identifier}-#{display_version}"
          ensure
            rm magic_temp_file
          end
        end

        # Installs the given gem.
        def gem_install(rbenv_root, gem)
          pp(:info, "Install the `#{gem}` gem")

          as_user do
            # Change the directory to avoid picking up any stray `.ruby-version` files.
            cd Pathname.new("/") do
              rbenv(rbenv_root) do |rbenv|
                sh rbenv, "exec", "gem", "install", "--no-document", gem
                sh rbenv, "rehash"
              end
            end
          end
        end

        # Sets up a special environment for rbenv to run in.
        def rbenv(rbenv_root, &block)
          # Set special values for certain rbenv environment variables, run the given block, and restore them
          # afterwards.
          ENV["RBENV_ROOT"], ENV["RBENV_DIR"], ENV["RBENV_HOOK_PATH"], ENV["RBENV_VERSION"] \
            = [ENV["RBENV_ROOT"], ENV["RBENV_DIR"], ENV["RBENV_HOOK_PATH"], ENV["RBENV_VERSION"]].tap do
            ENV["RBENV_ROOT"], ENV["RBENV_DIR"], ENV["RBENV_HOOK_PATH"], ENV["RBENV_VERSION"] \
              = [rbenv_root.to_s, nil, nil, nil]

            block.call((rbenv_root + "bin/rbenv").to_s)
          end
        end

        # Sets up a special environment for Git's SSH protocol.
        def git_ssh(git_ssh_executable, &block)
          # Set environment variables that direct Git to use the provided SSH wrapper, and restore them afterwards.
          ENV["SSH_AUTH_SOCK"], ENV["GIT_SSH"] = [ENV["SSH_AUTH_SOCK"], ENV["GIT_SSH"]].tap do
            ENV["SSH_AUTH_SOCK"], ENV["GIT_SSH"] = [nil, git_ssh_executable.to_s]
            block.call
          end
        end

        # Pretty prints the given message.
        def pp(type = nil, message = nil)
          if type
            puts Rake.application.formatters[type].format(message)
          else
            puts
          end
        end

        # Extracts Chef attributes from the given YAML file or directory hierarchy of files.
        def attributes_from_path(path)
          attributes = {}
          attribute_files = []

          if path.directory? && !path.symlink?
            path.children.each do |child|
              child_attributes, child_attribute_files = attributes_from_path(child)

              if child.directory?
                child_key = child.basename.to_s
                attributes[child_key] = deep_merge(attributes[child_key] || {}, child_attributes)
              else
                attributes = deep_merge(attributes, child_attributes)
              end

              attribute_files += child_attribute_files
            end
          elsif path.file? && path.extname == ".yml"
            attributes = YAML.load(path.open("rb") {|f| f.read}) || {}
            attribute_files.push(path)
          end

          [attributes, attribute_files]
        end

        # Deep merges the given `Hash`es.
        def deep_merge(lhs, rhs)
          if lhs.is_a?(Hash) && rhs.is_a?(Hash)
            lhs.merge(rhs) {|_, lhs_value, rhs_value| deep_merge(lhs_value, rhs_value)}
          else
            rhs
          end
        end
      end

      def self.included(klass)
        Rake::Application.class_eval do
          attr_accessor :formatters
        end

        klass.send(:include, InstanceMethods)
      end
    end

    class << self
      attr_reader :define_rake_tasks
    end

    @define_rake_tasks = Proc.new do |opts, user_opts|
      prefix = opts[:prefix]
      ssh_key_file = opts[:ssh_key_file]
      chef_attribute_path = opts[:chef_attribute_path]
      rbenv_dir = opts[:rbenv_dir]
      rbenv_version = opts[:rbenv_version]
      repo_url = opts[:repo_url]
      repo_branch = opts[:repo_branch]
      repo_dir = opts[:repo_dir]
      osx_bootstrap_executable = prefix + "bin/osx-bootstrap"

      namespace :osx_bootstrap do
        user_data_dir = prefix + "var/user_data"
        git_ssh_executable = user_data_dir + "ssh/git-ssh"
        ssh_installed = user_data_dir + "ssh/.installed.rake"
        command_line_tools_installed = user_data_dir + "command_line_tools/.installed.rake"
        rbenv_installed = user_data_dir + "rbenv/.installed-#{rbenv_version}.rake"
        chef_config_file = repo_dir + "config/client.rb"
        chef_installed = user_data_dir + "chef/.installed-#{repo_dir.basename.to_s}.rake"

        namespace :ssh do
          if ssh_key_file
            installed_key_file = user_data_dir + "ssh" + ssh_key_file.basename

            if installed_key_file != ssh_key_file
              with_parent_directory installed_key_file => ssh_key_file do
                pp(:info, "Write the SSH private key file to #{installed_key_file.to_s}")

                as_user do
                  # Copy the private key file and secure the copy.
                  cp ssh_key_file, installed_key_file
                  chmod 0600, installed_key_file
                end
              end
            end

            installed_key_deps = [installed_key_file]
          else
            installed_key_file = nil
            installed_key_deps = []
          end

          desc "Writes a Git SSH wrapper executable to #{git_ssh_executable.to_s.dump}"
          with_parent_directory git_ssh_executable => installed_key_deps do
            ssh_command = ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]
            ssh_command += ["-i", installed_key_file.to_s] \
              if installed_key_file
            ssh_command = ssh_command.map {|arg| Shellwords.escape(arg)}.join(" ")

            as_user do
              git_ssh_executable.open("wb") do |f|
                f.write(<<EOS
#!/usr/bin/env bash
#
# This script was auto-generated by OS X Bootstrap.

# Bail on any errors.
set -e

exec -- #{ssh_command} "$@"
EOS
                )
              end

              # Assign executable bits.
              chmod "+x", git_ssh_executable
            end
          end

          with_parent_directory ssh_installed => git_ssh_executable do
            as_user do
              touch ssh_installed
            end
          end
        end

        namespace :command_line_tools do
          clt_bom_file = Pathname.new("/System/Library/receipts/com.apple.pkg.CLTools_Executables.bom")
          clt_plist_file = Pathname.new("/System/Library/receipts/com.apple.pkg.CLTools_Executables.plist")

          file clt_bom_file do
            softwareupdate_install
          end

          file clt_plist_file do
            softwareupdate_install
          end

          with_parent_directory command_line_tools_installed => [clt_bom_file, clt_plist_file] do
            as_user do
              touch command_line_tools_installed
            end
          end
        end

        namespace :rbenv do
          ruby_build_dir = rbenv_dir + "plugins/ruby-build"
          ruby_build_definition = ruby_build_dir + "share/ruby-build/#{rbenv_version}"

          desc "Clones the rbenv repository into #{rbenv_dir.to_s.dump}"
          with_parent_directory rbenv_dir + ".git" => command_line_tools_installed do
            pp(:info, "Clone the rbenv repository")

            as_user do
              cd rbenv_dir do
                sh "git", "init"
                sh "git", "remote", "add", "--", "origin", "https://github.com/rbenv/rbenv"
                sh "git", "fetch"
                sh "git", "remote", "set-head", "--", "origin", "master"
                sh "git", "reset", "--hard", "origin/master"
              end
            end
          end

          desc "Clones the ruby-build repository into #{ruby_build_dir.to_s.dump}"
          directory (ruby_build_dir + ".git").to_s => [command_line_tools_installed, rbenv_dir] do
            pp(:info, "Clone the ruby-build repository")

            as_user do
              mkdir_p ruby_build_dir

              cd ruby_build_dir do
                sh "git", "init"
                sh "git", "remote", "add", "--", "origin", "https://github.com/rbenv/ruby-build"
                sh "git", "fetch"
                sh "git", "remote", "set-head", "--", "origin", "master"
                sh "git", "reset", "--hard", "origin/master"
              end
            end
          end

          desc "Updates the ruby-build repository"
          file ruby_build_definition => ruby_build_dir + ".git" do
            pp(:info, "Update the ruby-build repository")

            as_user do
              cd ruby_build_dir do
                sh "git", "pull"
              end
            end
          end

          desc "Installs the default rbenv Ruby"
          with_parent_directory rbenv_installed => [rbenv_dir + ".git", ruby_build_definition] do
            pp(:info, "Install rbenv Ruby version #{rbenv_version}")

            as_user do
              rbenv(rbenv_dir) do |rbenv|
                sh rbenv, "install", rbenv_version
              end

              # Set the default rbenv Ruby version.
              (rbenv_dir + "version").open("wb") {|f| f.write("#{rbenv_version}\n")}

              touch rbenv_installed
            end
          end
        end

        namespace :chef do
          installed_attribute_json_file = user_data_dir + "chef/attributes.json"
          installed_attribute_yaml_file = user_data_dir + "chef/attributes.yml"
          cheffile_lock = repo_dir + "Cheffile.lock"
          chef_client_executable = rbenv_dir + "versions/#{rbenv_version}/bin/chef-client"
          librarian_chef_executable = rbenv_dir + "versions/#{rbenv_version}/bin/librarian-chef"

          if chef_attribute_path
            attributes, deps = attributes_from_path(chef_attribute_path)

            deps.each {|dep| file dep}

            with_parent_directory installed_attribute_json_file => deps do
              pp(:info, "Write the JSONified Chef attribute file to #{installed_attribute_json_file.to_s}")

              as_user do
                installed_attribute_json_file.open("wb") {|f| f.write(JSON.generate(attributes))}
              end
            end

            if !deps.find {|dep| dep == installed_attribute_yaml_file}
              with_parent_directory installed_attribute_yaml_file => deps do
                pp(:info, "Write the YAMLized Chef attribute file to #{installed_attribute_yaml_file.to_s}")

                as_user do
                  installed_attribute_yaml_file.open("wb") {|f| f.write(YAML.dump(attributes))}
                end
              end
            end

            installed_attribute_deps = [installed_attribute_json_file, installed_attribute_yaml_file]
          else
            installed_attribute_deps = []
          end

          desc "Clones the user's Chef repository into #{repo_dir.to_s.dump}"
          with_parent_directory repo_dir => [ssh_installed, command_line_tools_installed] do
            pp(:info, "Clone the Chef repository at #{repo_url} (#{repo_branch})")

            as_user do
              git_ssh(git_ssh_executable) do
                sh "git", "clone", "-b", repo_branch, "--", repo_url, repo_dir.to_s
              end
            end
          end

          desc "Checks that the Chef client configuration file exists"
          file chef_config_file => repo_dir do
            raise "Please provide a Chef client configuration file located at #{chef_config_file.to_s.dump}" \
              if !chef_config_file.exist?
          end

          desc "Checks that the `Cheffile.lock` exists"
          file cheffile_lock => repo_dir do
            raise "Please provide a `Cheffile.lock` located at #{cheffile_lock.to_s.dump}" \
              if !cheffile_lock.exist?
          end

          file chef_client_executable => [rbenv_installed] do
            gem_install(rbenv_dir, "chef")
          end

          file librarian_chef_executable => [rbenv_installed] do
            gem_install(rbenv_dir, "librarian-chef")
          end

          desc "Runs `librarian-chef install` in the Chef repository"
          with_parent_directory chef_installed => [
              ssh_installed, command_line_tools_installed, rbenv_installed, chef_config_file, cheffile_lock,
              chef_client_executable, librarian_chef_executable
          ] + installed_attribute_deps do
            pp(:info, "Run `librarian-chef install` in the Chef repository")

            as_user do
              cd repo_dir do
                rbenv(rbenv_dir) do |rbenv|
                  git_ssh(git_ssh_executable) do
                    sh rbenv, "exec", "librarian-chef", "install"
                  end
                end
              end

              touch chef_installed
            end
          end
        end

        desc "Writes an executable to #{osx_bootstrap_executable.to_s.dump}"
        with_parent_directory osx_bootstrap_executable => [
            ssh_installed, rbenv_installed, command_line_tools_installed, chef_installed
        ] do
          rbenv_executable = rbenv_dir + "bin/rbenv"

          lines = []
          lines.push(["chef-client", "-z"])
          lines.push(["-c", chef_config_file.to_s])
          lines.push(["-j", (user_data_dir + "chef/attributes.json").to_s]) \
            if chef_attribute_path

          sudo_user_command = "sudo -E -u #{Shellwords.escape(ENV["SUDO_USER"])}"

          chef_client_command = lines.map do |args|
            args.map do |arg|
              Shellwords.escape(arg)
            end.join(" ")
          end.join(" \\\n            ")

          lines = [["--"]]
          lines.push(["--prefix", user_opts[:prefix].realpath.to_s]) \
            if user_opts[:prefix]
          lines.push(["--config-dir", user_opts[:config_dir].realpath.to_s]) \
            if user_opts[:config_dir]
          lines.push(["--rbenv-dir", user_opts[:rbenv_dir].realpath.to_s]) \
            if user_opts[:rbenv_dir]
          lines.push(["--rbenv-version", user_opts[:rbenv_version]]) \
            if user_opts[:rbenv_version]
          lines.push(["--branch", user_opts[:repo_branch]]) \
            if user_opts[:repo_branch]
          lines.push(["--ssh-key", user_opts[:ssh_key_file].realpath.to_s]) \
            if user_opts[:ssh_key_file]
          lines.push(["--chef-attribute-path", user_opts[:chef_attribute_path].realpath.to_s]) \
            if user_opts[:chef_attribute_path]
          lines.push(["--yes"]) \
            if user_opts[:yes_to_all]
          lines.push(["--verbose"]) \
            if user_opts[:verbose]
          lines.push(["--", user_opts[:repo_url]]) \
            if user_opts[:repo_url]

          cached_installer_args = lines.map do |args|
            args.map do |arg|
              Shellwords.escape(arg)
            end.join(" ")
          end.join(" \\\n                ")

          as_user do
            osx_bootstrap_executable.open("wb") do |f|
              f.write(<<EOS
#!/usr/bin/env bash
#
# This script was auto-generated by OS X Bootstrap.

# Bail on any errors.
set -e

if (( $EUID != 0 )); then
    echo "This script requires root privileges to run" >&2
    exit -- 1
fi

export -- RBENV_ROOT=#{Shellwords.escape(rbenv_dir.to_s)}

# Take no chances and regenerate the `PATH` environment variable.
eval -- "$(PATH="" /usr/libexec/path_helper)"
PATH=#{Shellwords.escape((rbenv_dir + "bin").to_s)}"${PATH:+":${PATH}"}"
PATH=#{Shellwords.escape((rbenv_dir + "shims").to_s)}"${PATH:+":${PATH}"}"

# Ensure that SSH authentication works off of the given private key *only*.
unset -- SSH_AUTH_SOCK

# Explicitly set the `RBENV_VERSION` environment variable to override any local versions set in `.ruby-version` files.
export -- RBENV_VERSION=$(rbenv global)

# Direct Git to use the provided SSH wrapper instead of standard `ssh`.
export -- GIT_SSH=#{Shellwords.escape(git_ssh_executable.to_s)}

case "$1" in
    "")
        cd -- #{Shellwords.escape(repo_dir.to_s)}

        sha1_old=$(git rev-parse --verify HEAD)
        #{sudo_user_command} -- git fetch -q
        sha1_new=$(git rev-parse --verify "HEAD@{upstream}")

        # Compare the old and new SHA-1 hashes and only take action if they are different.
        if [[ "$sha1_old" != "$sha1_new" ]]; then
            # Hard reset to the latest commit.
            #{sudo_user_command} -- git reset -q --hard "$sha1_new"

            if [[ -f "Cheffile" ]]; then
                #{sudo_user_command} -- #{Shellwords.escape(rbenv_executable.to_s)} exec librarian-chef install
            fi
        fi

        # Run the Chef client in local mode (`-z`) and point it to the repository's configuration file (by convention).
        exec -- #{Shellwords.escape(rbenv_executable.to_s)} exec #{chef_client_command}
        ;;

    self-update)
        shift -- 1

        if (( $# == 0 )); then
            # These are the installer's original command-line arguments.
            set #{cached_installer_args}
        fi

        exec -- #{Shellwords.escape(rbenv_executable.to_s)} exec ruby \\
            -e "$(curl -fsSL -- "https://raw.githubusercontent.com/carsomyr/osx-bootstrap/install/run")" \\
            -- "$@"
        ;;

    *)
        echo "osx-bootstrap: Unrecognized subcommand \\`$1\\`" >&2
        exit -- 1
        ;;
esac
EOS
              )
            end

            # Assign executable bits.
            chmod "+x", osx_bootstrap_executable
          end
        end
      end

      task default: osx_bootstrap_executable do
        # Display the post-installation notice.
        pp
        pp(:heading, <<EOS
Installation complete!

We've placed the <nobreak>#{osx_bootstrap_executable.basename.to_s.encode(xml: :text)}</nobreak> script in <nobreak>\
#{osx_bootstrap_executable.dirname.to_s.encode(xml: :text)}</nobreak>. Assuming that it's on your path, you can now run:

    sudo -- <nobreak>#{osx_bootstrap_executable.basename.to_s.encode(xml: :text)}</nobreak>

Each invocation will check the repository at\
 <nobreak>#{"#{repo_url} (#{repo_branch})".to_s.encode(xml: :text)}</nobreak>\
 for changes, and, if any, run `librarian-chef install` to update Chef cookbooks.

The `self-update` subcommand will run this installer with its original command-line arguments and regenerate\
 <nobreak>#{osx_bootstrap_executable.to_s.encode(xml: :text)}</nobreak>. Consequently, the new instance will take on\
 potentially different settings.

Happy provisioning, and don't hesitate to file issues against the project:

    https://github.com/carsomyr/osx-bootstrap
EOS
        )
      end
    end
  end
end

if __FILE__ == $0
  opts = {
      prefix: Pathname.new("/usr/local"),
      config_dir: Pathname.new("/Volumes/User Data"),
      rbenv_dir: Pathname.new("/usr/local/var/rbenv"),
      rbenv_version: "2.4.0",
      repo_url: "https://github.com/carsomyr/osx-bootstrap",
      repo_branch: "master",
      ssh_key_file: nil,
      chef_attribute_path: nil,
      verbose: false
  }

  user_opts = {}

  positional_args = OptionParser.new do |opt_spec|
    opt_spec.banner = "usage: #{Pathname.new(__FILE__).basename} [<options>] [[--] <dir>...]"

    opt_spec.separator ""
    opt_spec.separator "optional arguments:"

    opt_spec.on("--prefix PREFIX", "specify the installation prefix") do |prefix|
      user_opts[:prefix] = Pathname.new(prefix)
    end

    opt_spec.on("--config-dir CONFIG_DIR", "specify the configuration directory") do |config_dir|
      user_opts[:config_dir] = Pathname.new(config_dir)
    end

    opt_spec.on("--rbenv-dir RBENV_DIR", "specify the rbenv installation directory") do |rbenv_dir|
      user_opts[:rbenv_dir] = Pathname.new(rbenv_dir)
    end

    opt_spec.on("--rbenv-version RBENV_VERSION", "specify the default rbenv Ruby version") do |rbenv_version|
      user_opts[:rbenv_version] = rbenv_version
    end

    opt_spec.on("-b", "--branch BRANCH", "specify the Chef repository branch to checkout") do |repo_branch|
      user_opts[:repo_branch] = repo_branch
    end

    opt_spec.on("-k", "--ssh-key SSH_KEY", "provide an SSH private key") do |ssh_key_file|
      user_opts[:ssh_key_file] = Pathname.new(ssh_key_file)
    end

    opt_spec.on("-c", "--chef-attribute-path CHEF_ATTRIBUTE_PATH", "provide a `chef-client` attribute file in YAML or" \
                " as a directory hierarchy of files") do |chef_attribute_path|
      user_opts[:chef_attribute_path] = Pathname.new(chef_attribute_path)
    end

    opt_spec.on("-y", "--yes", "a non-interactive \"yes\" answer to all prompts") do
      user_opts[:yes_to_all] = true
    end

    opt_spec.on("-v", "--verbose", "be verbose") do
      user_opts[:verbose] = true
    end
  end.parse(ARGV)

  case positional_args.size
    when 1
      user_opts[:repo_url] = positional_args.first
    when 0
      # Use default values.
    else
      raise "Please specify exactly one Git repository"
  end

  opts = opts.merge(user_opts)

  # Mix in our helpers.
  class << self
    include OsX::Bootstrap::RakeHelpers
  end

  if STDOUT.tty?
    tty_blue = "\033[34m"
    tty_green = "\033[32m"
    tty_reset = "\033[0m"
  else
    tty_blue = ""
    tty_green = ""
    tty_reset = ""
  end

  # Set the pretty print formatters.
  Rake.application.formatters = {
      heading: OsX::Bootstrap::Formatter.new(
          "#{tty_blue}*#{"-" * 118}*#{tty_reset}",
          "#{tty_blue}*#{"-" * 118}*#{tty_reset}",
          "#{tty_blue}|#{tty_reset} ", " #{tty_blue}|#{tty_reset}", 116
      ),
      info: OsX::Bootstrap::Formatter.new(
          "", "", " #{tty_green}=>#{tty_reset} "
      )
  }

  prefix = opts[:prefix]
  config_dir = opts[:config_dir]
  ssh_key_file = opts[:ssh_key_file]
  chef_attribute_path = opts[:chef_attribute_path]
  rbenv_dir = opts[:rbenv_dir]
  rbenv_version = opts[:rbenv_version]
  yes_to_all = opts[:yes_to_all]
  repo_url = opts[:repo_url]
  repo_branch = opts[:repo_branch]

  existing_install_dir = prefix + "var/user_data"

  config_dir = existing_install_dir \
    if !config_dir.directory? && existing_install_dir.directory?

  if !ssh_key_file
    ssh_key_file = Pathname.glob("#{config_dir.to_s}/ssh/id_{rsa,dsa,ecdsa}").first
    opts[:ssh_key_file] = ssh_key_file
  end

  raise "No SSH private key file found at #{ssh_key_file.to_s.dump}" \
    if ssh_key_file && !ssh_key_file.file?

  chef_attribute_dir = config_dir + "chef"

  if !chef_attribute_path && chef_attribute_dir.directory?
    chef_attribute_path = chef_attribute_dir
    opts[:chef_attribute_path] = chef_attribute_path
  end

  raise "No Chef attributes found at #{chef_attribute_path.to_s.dump}" \
    if chef_attribute_path && !chef_attribute_path.exist?

  repo_basename_pattern = Regexp.new("\\A.+[/:](.+)\\z")
  m = repo_basename_pattern.match(repo_url)

  raise "Invalid Git repository URL #{repo_url.dump}" \
    if !m

  opts[:repo_dir] = prefix + "var/user_data/git/#{m[1]}-#{Digest::SHA1.hexdigest(repo_url)[0...7]}"

  pp(:heading, <<EOS
Hello from the OS X Bootstrap installer!

We're just a few minutes away from provisioning your machine with Chef. Before proceeding, please confirm these\
 settings.

Chef repository:
    <nobreak>#{"#{repo_url} (#{repo_branch})".encode(xml: :text)}</nobreak>

SSH private key:
    <nobreak>#{((ssh_key_file && ssh_key_file.to_s) || "(not found)").encode(xml: :text)}</nobreak>

Chef attribute path<nobreak>#{((chef_attribute_path && " (#{chef_attribute_path.ftype})") || "").encode(xml: :text)}\
</nobreak>:
    <nobreak>#{((chef_attribute_path && chef_attribute_path.to_s) || "(not found)").encode(xml: :text)}</nobreak>

install prefix:
    <nobreak>#{prefix.to_s.encode(xml: :text)}</nobreak>

rbenv root:
    <nobreak>#{rbenv_dir.to_s.encode(xml: :text)}</nobreak>

rbenv version:
    <nobreak>#{rbenv_version.encode(xml: :text)}</nobreak>

You can rerun this script with `-h` to get a menu of command-line options for overriding any of the above.
EOS
  )
  pp

  if !yes_to_all
    print "\n #{tty_green}=>#{tty_reset} Do you wish to continue (y/n)? "

    answer = STDIN.getc

    print "\n"

    if answer != "y"
      if STDIN.tty?
        pp(:info, "Installation not attempted.")
      else
        pp(:info, "Installation not attempted. If you are running this script non-interactively, consider providing" \
                  " the `-y` flag option.")
      end

      exit 1
    end
  end

  raise "Root privileges are needed" \
    if Process.euid != 0

  instance_exec(opts, user_opts, &OsX::Bootstrap.define_rake_tasks).invoke
end
