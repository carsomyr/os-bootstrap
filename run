#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
#
# Copyright 2014 Roy Liu
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

require "digest"
require "fileutils"
require "json"
require "optparse"
require "pathname"
require "rake"
require "rbconfig"
require "rexml/document"
require "shellwords"
require "yaml"

module OsX
  module Bootstrap
    # A formatter for framed, line-wrapped messages.
    class Formatter
      def initialize(header, footer, line_header, line_footer = nil, line_max = nil)
        @header = header
        @footer = footer
        @line_header = line_header
        @line_footer = line_footer
        @line_max = line_max
      end

      # Formats the given string: Wraps lines to under the line size limit while applying headers and footers.
      def format(str)
        acc = ""

        acc = @header + "\n" \
          if @header

        single_space_pattern = Regexp.new(" ")
        line_acc = nil

        REXML::Document.new("<root>#{str}</root>").root.children.each do |node|
          case node
            when REXML::Text
              first_line = true

              node.value.split("\n", -1).each do |line|
                if !first_line
                  acc += emit_line(line_acc || "")
                  line_acc = nil
                end

                first_word = true

                # Apparently the string `" "` has special meaning for Ruby regular expressions, so we use a regex to
                # force the issue.
                line.split(single_space_pattern, -1).each do |word|
                  if line_acc
                    if !first_word
                      sep = " "
                    else
                      sep = ""
                    end

                    if @line_max && line_acc.size + sep.size + word.size > @line_max
                      # Emit the accumulator and move on to building the next line.
                      acc += emit_line(line_acc)
                    else
                      # Accumulate the word.
                      line_acc += sep + word
                      first_word = false

                      next
                    end
                  end

                  # Trim the word down to size.
                  while @line_max && word.size > @line_max
                    acc += emit_line(word[0...(@line_max - 1)] + "-")
                    word = word[(@line_max - 1)...(word.size)]
                  end

                  line_acc = word
                  first_word = false
                end

                first_line = false
              end
            when REXML::Element
              case node.name
                when "nobreak"
                  first_line = true

                  (node.text || "").split("\n", -1).each do |line|
                    if !first_line
                      acc += emit_line(line_acc || "")
                      line_acc = nil
                    end

                    if line_acc
                      if @line_max && line_acc.size + line.size > @line_max
                        # Emit the accumulator and move on to building the next line.
                        acc += emit_line(line_acc)
                      else
                        # Accumulate the line.
                        line_acc += line
                        first_line = false

                        next
                      end
                    end

                    # Trim the line down to size.
                    while @line_max && line.size > @line_max
                      acc += emit_line(line[0...(@line_max - 1)] + "-")
                      line = line[(@line_max - 1)...(line.size)]
                    end

                    line_acc = line
                    first_line = false
                  end
                else
                  raise "Invalid node name #{node.name.dump}"
              end
            else
              raise "Invalid node class #{node.class.name.dump}"
          end
        end

        acc += emit_line(line_acc) \
          if line_acc

        acc += @footer + "\n" \
          if @footer

        acc
      end

      private

      # Emits a single line of output.
      def emit_line(word)
        if @line_max
          @line_header + word + " " * (@line_max - word.size) + @line_footer + "\n"
        else
          @line_header + word + "\n"
        end
      end
    end

    # Some helpers to reduce boilerplate in Rake tasks.
    module RakeHelpers
      module InstanceMethods
        # Sets up a special environment for rbenv to run in.
        def rbenv(rbenv_root, &block)
          # Set special values for certain rbenv environment variables, run the given block, and restore them
          # afterwards.
          ENV["RBENV_ROOT"], ENV["RBENV_DIR"], ENV["RBENV_HOOK_PATH"], ENV["RBENV_VERSION"] \
            = [ENV["RBENV_ROOT"], ENV["RBENV_DIR"], ENV["RBENV_HOOK_PATH"], ENV["RBENV_VERSION"]].tap do
            ENV["RBENV_ROOT"], ENV["RBENV_DIR"], ENV["RBENV_HOOK_PATH"], ENV["RBENV_VERSION"] \
              = [rbenv_root.to_s, nil, nil, nil]

            block.call((rbenv_root + "bin/rbenv").to_s)
          end
        end

        # Wraps the given command in an SSH agent session and adds the given private key file to it.
        def ssh_wrap(command, key_file = nil)
          if command.is_a?(Array)
            command = command.map { |arg| Shellwords.escape(arg) }.join(" ")
          end

          if key_file
            subcommand = "ssh-add -- #{Shellwords.escape(key_file.to_s)} 2> /dev/null && #{command}"
            "ssh-agent -- bash -c #{Shellwords.escape(subcommand)}"
          else
            command
          end
        end

        # Pretty prints the given message.
        def pp(type = nil, message = nil)
          if type
            puts Rake.application.formatters[type].format(message)
          else
            puts
          end
        end

        # Recursively traverses a directory of `_attributes.yml` files and merges them into one.
        def attributes_from_dir(dir)
          attribute_file = dir + "_attributes.yml"

          if attribute_file.file?
            attribute_files = [attribute_file]
            attributes = YAML.load(attribute_file.open("rb") { |f| f.read }) || {}

            dir.children.select do |dir|
              dir.directory? && !dir.symlink?
            end.each do |child_dir|
              child_attributes, child_attribute_files = attributes_from_dir(child_dir)

              child_key = child_dir.basename.to_s
              attributes[child_key] = deep_merge(attributes[child_key] || {}, child_attributes)
              attribute_files += child_attribute_files
            end

            [attributes, attribute_files]
          else
            [{}, []]
          end
        end

        # Deep merges the given `Hash`es.
        def deep_merge(lhs, rhs)
          if lhs.is_a?(Hash) && rhs.is_a?(Hash)
            lhs.merge(rhs) { |_, lhs_value, rhs_value| deep_merge(lhs_value, rhs_value) }
          else
            rhs
          end
        end
      end

      def self.included(klass)
        Rake::Application.class_eval do
          attr_accessor :formatters
        end

        klass.send(:include, InstanceMethods)
      end
    end

    class << self
      attr_reader :define_rake_tasks
    end

    @define_rake_tasks = Proc.new do |opts, user_opts|
      main_task = nil

      namespace :osx_bootstrap do
        prefix = opts[:prefix]
        ssh_key_file = opts[:ssh_key_file]
        chef_attribute_path = opts[:chef_attribute_path]
        rbenv_dir = opts[:rbenv_dir]
        rbenv_version = opts[:rbenv_version]
        repo_url = opts[:repo_url]
        repo_branch = opts[:repo_branch]
        repo_dir = opts[:repo_dir]
        cache_dir = prefix + "var/osx-bootstrap/cache"
        chef_config_file = repo_dir + "config/client.rb"
        osx_bootstrap_executable = prefix + "bin/osx-bootstrap"
        installed_key_file = ssh_key_file && prefix + "var/osx-bootstrap/ssh" + ssh_key_file.basename

        desc "Checks for root privileges"
        task :check_root do
          raise "Root privileges are needed" \
            if Process.euid != 0
        end

        namespace :ssh do
          if ssh_key_file
            file ssh_key_file.to_s do
              raise "No SSH private key file found at #{ssh_key_file.to_s.dump}" \
                if !ssh_key_file.file?
            end

            directory installed_key_file.parent.to_s

            file installed_key_file.to_s => [ssh_key_file.to_s, installed_key_file.parent.to_s] do
              pp(:info, "Write the SSH private key file to #{installed_key_file.to_s}")

              # Copy the private key file and secure the copy.
              FileUtils.copy(ssh_key_file, installed_key_file)
              FileUtils.chmod(0600, installed_key_file)
            end

            desc "Installs the SSH private key file for later use"
            task install_key: [installed_key_file.to_s]
          else
            task :install_key
          end

          task install: [:install_key]
        end

        namespace :command_line_tools do
          magic_temp_file = Pathname.new("/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress")
          clt_bom = Pathname.new("/var/db/receipts/com.apple.pkg.CLTools_Executables.bom")
          clt_plist = Pathname.new("/var/db/receipts/com.apple.pkg.CLTools_Executables.plist")

          # See `http://macops.ca/installing-command-line-tools-automatically-on-mavericks/`.
          desc "Ensures that the magic file for faking an on-demand installation is in place"
          file magic_temp_file.to_s do
            FileUtils.touch(magic_temp_file)
          end

          file clt_bom.to_s => [:softwareupdate_install]
          file clt_plist.to_s => [:softwareupdate_install]

          desc "Installs the command-line tools package via the `softwareupdate` tool"
          task softwareupdate_install: [:check_root, magic_temp_file.to_s] do
            next \
              if clt_bom.file? && clt_plist.file?

            pp(:info, "Run `softwareupdate` to get the manifest of available updates")

            sh "softwareupdate", "-l"

            # After `softwareupdate` has run, look in the plist of recommended updates. Some sort of command-line tools
            # package should be there.

            xml = IO.popen(["plutil", "-convert", "xml1", "-o", "-", "--",
                            "/Library/Preferences/com.apple.SoftwareUpdate.plist"]) do |io|
              io.read
            end

            exit_status = $?.exitstatus

            raise "`plutil` returned nonzero exit status #{exit_status}" \
              if exit_status != 0

            # Create an XPath query for the package information.
            doc = REXML::Document.new(xml)
            node = doc.elements["/plist" \
                "/dict" \
                "/key[text()=\"RecommendedUpdates\"]" \
                "/following::array[position()=1]" \
                "/dict[key[text()=\"Display Name\"]" \
                "/following::string[position()=1 and starts-with(text(), \"Command Line \")]]"
            ]

            raise "Could not find the necessary metadata for installing the command-line tools package" \
              if !node

            identifier = node.elements["key[text()=\"Identifier\"]/following::string[position()=1]/text()"]
            display_version = node.elements["key[text()=\"Display Version\"]/following::string[position()=1]/text()"]

            pp(:info, "Install #{identifier} via `softwareupdate`")

            sh "softwareupdate", "-v", "-i", "#{identifier}-#{display_version}"
          end

          task cleanup: [:softwareupdate_install, magic_temp_file.to_s] do
            magic_temp_file.delete
          end

          task install: [:cleanup, clt_bom.to_s, clt_plist.to_s]
        end

        namespace :rbenv do
          ruby_build_dir = (rbenv_dir + "plugins/ruby-build")
          ruby_build_definition = ruby_build_dir + "share/ruby-build/#{rbenv_version}"
          rbenv_ruby_token = cache_dir + "#{rbenv_version}/.ruby"

          desc "Clones the rbenv repository into #{rbenv_dir.to_s.dump}"
          directory rbenv_dir.to_s => [:check_root, "command_line_tools:install"] do
            pp(:info, "Clone the rbenv repository")

            sh "git", "clone", "--", "https://github.com/sstephenson/rbenv", rbenv_dir.to_s
          end

          desc "Clones the ruby-build repository into #{ruby_build_dir.to_s.dump}"
          directory ruby_build_dir.to_s => [:check_root, "command_line_tools:install"] do
            pp(:info, "Clone the ruby-build repository")

            sh "git", "clone", "--", "https://github.com/sstephenson/ruby-build", ruby_build_dir.to_s
          end

          desc "Updates the ruby-build repository"
          file ruby_build_definition.to_s => [ruby_build_dir.to_s] do
            pp(:info, "Update the ruby-build repository")

            Dir.chdir(ruby_build_dir) do
              sh "git", "pull"
            end
          end

          directory rbenv_ruby_token.parent.to_s

          desc "Installs the default rbenv Ruby"
          file rbenv_ruby_token.to_s => [rbenv_dir.to_s, ruby_build_definition.to_s, rbenv_ruby_token.parent.to_s] do
            pp(:info, "Install rbenv Ruby version #{rbenv_version}")

            rbenv(rbenv_dir) do |rbenv|
              sh rbenv, "install", rbenv_version
            end

            # Set the default rbenv Ruby version.
            (rbenv_dir + "version").open("wb") { |f| f.write("#{rbenv_version}\n") }

            FileUtils.touch(rbenv_ruby_token)
          end

          task install: [rbenv_ruby_token.to_s]
        end

        namespace :chef do
          bundle_executable = rbenv_dir + "versions/#{rbenv_version}/bin/bundle"
          chef_client_executable = rbenv_dir + "versions/#{rbenv_version}/bin/chef-client"
          gemfile_lock = repo_dir + "Gemfile.lock"
          gemfile_token = cache_dir + "#{rbenv_version}/.Gemfile.lock"
          cheffile_lock = repo_dir + "Cheffile.lock"
          cheffile_token = cache_dir + "#{rbenv_version}/.Cheffile.lock"
          installed_attribute_file = prefix + "var/osx-bootstrap/chef/attributes.json"

          if chef_attribute_path
            if chef_attribute_path.directory?
              attributes, deps = attributes_from_dir(chef_attribute_path)
              deps = deps.map { |dep| dep.to_s }

              deps.each { |dep| file dep.to_s }
            elsif chef_attribute_path.file?
              attributes = YAML.load(chef_attribute_path.open("rb") { |f| f.read }) || {}
              deps = [chef_attribute_path.to_s]

              file chef_attribute_path.to_s
            else
              raise "No Chef attribute file found at #{chef_attribute_path.to_s.dump}" \
                if !chef_attribute_path.file?
            end

            directory installed_attribute_file.parent.to_s

            file installed_attribute_file.to_s => [*deps, installed_attribute_file.parent.to_s] do
              pp(:info, "Write the JSONified Chef attribute file to #{installed_attribute_file.to_s}")

              installed_attribute_file.open("wb") { |f| f.write(JSON.generate(attributes)) }
            end

            desc "Installs the Chef attribute file for later use"
            task install_attributes: [installed_attribute_file.to_s]
          else
            task :install_attributes
          end

          desc "Clones the user's Chef repository into #{repo_dir.to_s.dump}"
          directory repo_dir.to_s => [:check_root, "ssh:install", "command_line_tools:install"] do
            pp(:info, "Clone the Chef repository at #{repo_url} (#{repo_branch})")

            git_command = ssh_wrap(
                ["git", "clone", "-b", repo_branch, "--", repo_url, repo_dir.to_s],
                installed_key_file
            )

            # Isolate the command in an SSH agent process to ensure authentication success.
            sh git_command
          end

          desc "Checks that the Chef client configuration file exists"
          file chef_config_file.to_s => [repo_dir.to_s] do
            raise "Please provide a Chef client configuration file located at #{chef_config_file.to_s.dump}" \
              if !chef_config_file.exist?
          end

          file bundle_executable.to_s => [:gem_install]
          file chef_client_executable.to_s => [:gem_install]

          desc "Runs `gem install` with the default rbenv Ruby"
          task gem_install: [:check_root, "rbenv:install"] do
            next \
              if bundle_executable.executable? && chef_client_executable.executable?

            pp(:info, "Install the `bundler` and `chef` gems")

            # Change the directory to avoid picking up any stray `.ruby-version` files.
            Dir.chdir(Pathname.new("/")) do
              rbenv(rbenv_dir) do |rbenv|
                sh rbenv, "exec", "gem", "install", "--no-document", "bundler", "chef"
                sh rbenv, "rehash"
              end
            end
          end

          directory gemfile_token.parent.to_s

          desc "Checks that the `Gemfile.lock` exists"
          file gemfile_lock.to_s => [repo_dir.to_s, gemfile_token.parent.to_s] do
            raise "Please provide a `Gemfile.lock` located at #{gemfile_lock.to_s.dump}" \
              if !gemfile_lock.exist?
          end

          desc "Runs `bundle install` in the Chef repository"
          file gemfile_token.to_s => [bundle_executable.to_s, gemfile_lock.to_s] do
            pp(:info, "Run `bundle install` in the Chef repository")

            Dir.chdir(repo_dir) do
              rbenv(rbenv_dir) do |rbenv|
                sh rbenv, "exec", "bundle", "install"
              end
            end

            FileUtils.touch(gemfile_token)
          end

          directory cheffile_token.parent.to_s

          desc "Checks that the `Cheffile.lock` exists"
          file cheffile_lock.to_s => [repo_dir.to_s, cheffile_token.parent.to_s] do
            raise "Please provide a `Cheffile.lock` located at #{cheffile_lock.to_s.dump}" \
              if !cheffile_lock.exist?
          end

          desc "Runs `librarian-chef install` in the Chef repository"
          file cheffile_token.to_s => [bundle_executable.to_s, cheffile_lock.to_s, gemfile_token.to_s] do
            pp(:info, "Run `librarian-chef install` in the Chef repository")

            Dir.chdir(repo_dir) do
              rbenv(rbenv_dir) do |rbenv|
                sh rbenv, "exec", "bundle", "exec", "librarian-chef", "install"
              end
            end

            FileUtils.touch(cheffile_token)
          end

          task install: [:install_attributes,
                         chef_client_executable.to_s, chef_config_file.to_s,
                         gemfile_token.to_s, cheffile_token.to_s]
        end

        directory osx_bootstrap_executable.parent.to_s

        desc "Writes an executable to #{osx_bootstrap_executable.to_s.dump}"
        file osx_bootstrap_executable.to_s => [:check_root, "ssh:install", "rbenv:install", "chef:install",
                                               osx_bootstrap_executable.parent.to_s] do
          rbenv_executable = rbenv_dir + "bin/rbenv"

          # Isolate these commands in an SSH agent process to ensure authentication success.
          git_command = ssh_wrap(["git", "fetch", "-q"], installed_key_file)
          bundle_command = ssh_wrap(
              [rbenv_executable.to_s, "exec", "bundle", "install"],
              installed_key_file
          )
          librarian_chef_command = ssh_wrap(
              [rbenv_executable.to_s, "exec", "bundle", "exec", "librarian-chef", "install"],
              installed_key_file
          )

          lines = []
          lines.push(["chef-client", "-z"])
          lines.push(["-c", chef_config_file.to_s])
          lines.push(["-j", (prefix + "var/osx-bootstrap/chef/attributes.json").to_s]) \
            if chef_attribute_path

          chef_client_command = lines.map do |args|
            args.map do |arg|
              Shellwords.escape(arg)
            end.join(" ")
          end.join(" \\\n            ")

          ruby_executable = Pathname.new(RbConfig::CONFIG["bindir"]) \
            + (RbConfig::CONFIG["RUBY_INSTALL_NAME"] + RbConfig::CONFIG["EXEEXT"])

          lines = [["--"]]
          lines.push(["--prefix", user_opts[:prefix].realpath.to_s]) \
            if user_opts[:prefix]
          lines.push(["--config-dir", user_opts[:config_dir].realpath.to_s]) \
            if user_opts[:config_dir]
          lines.push(["--rbenv-dir", user_opts[:rbenv_dir].realpath.to_s]) \
            if user_opts[:rbenv_dir]
          lines.push(["--rbenv-version", user_opts[:rbenv_version]]) \
            if user_opts[:rbenv_version]
          lines.push(["--branch", user_opts[:repo_branch]]) \
            if user_opts[:repo_branch]
          lines.push(["--ssh-key", user_opts[:ssh_key_file].realpath.to_s]) \
            if user_opts[:ssh_key_file]
          lines.push(["--chef-attribute-path", user_opts[:chef_attribute_path].realpath.to_s]) \
            if user_opts[:chef_attribute_path]
          lines.push(["--yes"]) \
            if user_opts[:yes_to_all]
          lines.push(["--verbose"]) \
            if user_opts[:verbose]
          lines.push(["--", user_opts[:repo_url]]) \
            if user_opts[:repo_url]

          cached_installer_args = lines.map do |args|
            args.map do |arg|
              Shellwords.escape(arg)
            end.join(" ")
          end.join(" \\\n                ")

          osx_bootstrap_executable.open("wb") do |f|
            f.write(<<EOS
#!/usr/bin/env bash
#
# This script was auto-generated by OS X Bootstrap.

# Bail on any errors.
set -e

if (( $EUID != 0 )); then
    echo "This script requires root privileges to run" >&2
    exit -- 1
fi

export -- RBENV_ROOT=#{Shellwords.escape(rbenv_dir.to_s)}

# Take no chances and regenerate the `PATH` environment variable.
eval -- "$(PATH="" /usr/libexec/path_helper)"
PATH=#{Shellwords.escape((rbenv_dir + "bin").to_s)}"${PATH:+":${PATH}"}"
PATH=#{Shellwords.escape((rbenv_dir + "shims").to_s)}"${PATH:+":${PATH}"}"

# Ensure that SSH authentication works off of the given private key *only*.
unset -- SSH_AUTH_SOCK

case "$1" in
    "")
        cd -- #{Shellwords.escape(repo_dir.to_s)}

        sha1_old=$(git rev-parse --verify HEAD)
        #{git_command}
        sha1_new=$(git rev-parse --verify "HEAD@{upstream}")

        # Compare the old and new SHA-1 hashes and only take action if they are different.
        if [[ "$sha1_old" != "$sha1_new" ]]; then
            # Hard reset to the latest commit.
            git reset -q --hard "$sha1_new"

            if [[ -f "Gemfile" ]]; then
                #{bundle_command}

                if [[ -f "Cheffile" ]]; then
                    #{librarian_chef_command}
                fi
            fi
        fi

        # Run the Chef client in local mode (`-z`) and point it to the repository's configuration file (by convention).
        exec -- #{Shellwords.escape(rbenv_executable.to_s)} exec #{chef_client_command}
        ;;

    self-update)
        shift -- 1

        if (( $# == 0 )); then
            # These are the installer's original command-line arguments.
            set #{cached_installer_args}
        fi

        exec -- #{Shellwords.escape(ruby_executable.to_s)} \\
            -e "$(curl -fsSL -- "https://raw.githubusercontent.com/carsomyr/osx-bootstrap/install/run")" \\
            -- "$@"
        ;;

    *)
        echo "osx-bootstrap: Unrecognized subcommand \\`$1\\`" >&2
        exit -- 1
        ;;
esac
EOS
            )
          end

          # Assign executable bits.
          FileUtils.chmod("+x", osx_bootstrap_executable)
        end

        main_task = task install: [osx_bootstrap_executable.to_s] do
          # Display the post-installation notice.
          pp
          pp(:heading, <<EOS
Installation complete!

We've placed the <nobreak>#{osx_bootstrap_executable.basename.to_s.encode(xml: :text)}</nobreak> script in <nobreak>\
#{osx_bootstrap_executable.dirname.to_s.encode(xml: :text)}</nobreak>. Assuming that it's on your path, you can now run:

    sudo -- <nobreak>#{osx_bootstrap_executable.basename.to_s.encode(xml: :text)}</nobreak>

Each invocation will check the repository at\
 <nobreak>#{"#{repo_url} (#{repo_branch})".to_s.encode(xml: :text)}</nobreak>\
 for changes, and, if any, run `bundle install` followed by `bundle exec librarian-chef install` to update Ruby gems\
 and Chef cookbooks, respectively.

The `self-update` subcommand will run this installer with its original command-line arguments and regenerate\
 <nobreak>#{osx_bootstrap_executable.to_s.encode(xml: :text)}</nobreak>. Consequently, the new instance will take on\
 potentially different settings.

Happy provisioning, and don't hesitate to file issues against the project:

    https://github.com/carsomyr/osx-bootstrap
EOS
          )
        end
      end

      main_task
    end
  end
end

if __FILE__ == $0
  opts = {
      prefix: Pathname.new("/usr/local"),
      config_dir: Pathname.new("/Volumes/OS X Bootstrap"),
      rbenv_dir: Pathname.new("/opt/rbenv"),
      rbenv_version: "2.1.4",
      repo_url: "https://github.com/carsomyr/osx-bootstrap",
      repo_branch: "master",
      ssh_key_file: nil,
      chef_attribute_path: nil,
      verbose: false
  }

  user_opts = {}

  positional_args = OptionParser.new do |opt_spec|
    opt_spec.banner = "usage: #{Pathname.new(__FILE__).basename} [<options>] [[--] <dir>...]"

    opt_spec.separator ""
    opt_spec.separator "optional arguments:"

    opt_spec.on("--prefix PREFIX", "specify the installation prefix") do |prefix|
      user_opts[:prefix] = Pathname.new(prefix)
    end

    opt_spec.on("--config-dir CONFIG_DIR", "specify the configuration directory") do |config_dir|
      user_opts[:config_dir] = Pathname.new(config_dir)
    end

    opt_spec.on("--rbenv-dir RBENV_DIR", "specify the rbenv installation directory") do |rbenv_dir|
      user_opts[:rbenv_dir] = Pathname.new(rbenv_dir)
    end

    opt_spec.on("--rbenv-version RBENV_VERSION", "specify the default rbenv Ruby version") do |rbenv_version|
      user_opts[:rbenv_version] = rbenv_version
    end

    opt_spec.on("-b", "--branch BRANCH", "specify the Chef repository branch to checkout") do |repo_branch|
      user_opts[:repo_branch] = repo_branch
    end

    opt_spec.on("-k", "--ssh-key SSH_KEY", "provide an SSH private key") do |ssh_key_file|
      user_opts[:ssh_key_file] = Pathname.new(ssh_key_file)
    end

    opt_spec.on("-c", "--chef-attribute-path CHEF_ATTRIBUTE_PATH", "provide a `chef-client` attribute file in YAML or" \
                " as a directory hierarchy of `_attributes.yml` files") do |chef_attribute_path|
      user_opts[:chef_attribute_path] = Pathname.new(chef_attribute_path)
    end

    opt_spec.on("-y", "--yes", "a non-interactive \"yes\" answer to all prompts") do
      user_opts[:yes_to_all] = true
    end

    opt_spec.on("-v", "--verbose", "be verbose") do
      user_opts[:verbose] = true
    end
  end.parse(ARGV)

  case positional_args.size
    when 1
      user_opts[:repo_url] = positional_args.first
    when 0
      # Use default values.
    else
      raise "Please specify exactly one Git repository"
  end

  opts = opts.merge(user_opts)

  # Mix in our helpers.
  class << self
    include OsX::Bootstrap::RakeHelpers
  end

  if STDOUT.tty?
    tty_blue = "\033[34m"
    tty_green = "\033[32m"
    tty_reset = "\033[0m"
  else
    tty_blue = ""
    tty_green = ""
    tty_reset = ""
  end

  # Set the pretty print formatters.
  Rake.application.formatters = {
      heading: OsX::Bootstrap::Formatter.new(
          "#{tty_blue}*#{"-" * 118}*#{tty_reset}",
          "#{tty_blue}*#{"-" * 118}*#{tty_reset}",
          "#{tty_blue}|#{tty_reset} ", " #{tty_blue}|#{tty_reset}", 116
      ),
      info: OsX::Bootstrap::Formatter.new(
          "", "", " #{tty_green}=>#{tty_reset} "
      )
  }

  prefix = opts[:prefix]
  config_dir = opts[:config_dir]
  ssh_key_file = opts[:ssh_key_file]
  chef_attribute_path = opts[:chef_attribute_path]
  rbenv_dir = opts[:rbenv_dir]
  rbenv_version = opts[:rbenv_version]
  yes_to_all = opts[:yes_to_all]
  repo_url = opts[:repo_url]
  repo_branch = opts[:repo_branch]

  if !ssh_key_file
    ssh_key_file = Pathname.glob("#{config_dir.to_s}/ssh/id_{rsa,dsa,ecdsa}").first
    opts[:ssh_key_file] = ssh_key_file
  end

  default_attribute_file = config_dir + "chef/_attributes.yml"

  if !chef_attribute_path && default_attribute_file.file?
    chef_attribute_path = default_attribute_file.parent
    opts[:chef_attribute_path] = chef_attribute_path
  end

  repo_basename_pattern = Regexp.new("\\A.+[/:](.+)\\z")
  m = repo_basename_pattern.match(repo_url)

  raise "Invalid Git repository URL #{repo_url.dump}" \
    if !m

  opts[:repo_dir] = prefix + "var/osx-bootstrap/git/#{m[1]}-#{Digest::SHA1.hexdigest(repo_url)[0...7]}"

  pp(:heading, <<EOS
Hello from the OS X Bootstrap installer!

We're just a few minutes away from provisioning your machine with Chef. Before proceeding, please confirm these\
 settings.

Chef repository:
    <nobreak>#{"#{repo_url} (#{repo_branch})".encode(xml: :text)}</nobreak>

SSH private key:
    <nobreak>#{((ssh_key_file && ssh_key_file.to_s) || "(not found)").encode(xml: :text)}</nobreak>

Chef attribute path<nobreak>#{((chef_attribute_path && " (#{chef_attribute_path.ftype})") || "").encode(xml: :text)}\
</nobreak>:
    <nobreak>#{((chef_attribute_path && chef_attribute_path.to_s) || "(not found)").encode(xml: :text)}</nobreak>

install prefix:
    <nobreak>#{prefix.to_s.encode(xml: :text)}</nobreak>

rbenv root:
    <nobreak>#{rbenv_dir.to_s.encode(xml: :text)}</nobreak>

rbenv version:
    <nobreak>#{rbenv_version.encode(xml: :text)}</nobreak>

You can rerun this script with `-h` to get a menu of command-line options for overriding any of the above.
EOS
  )
  pp

  if !yes_to_all
    print "\n #{tty_green}=>#{tty_reset} Do you wish to continue (y/n)? "

    answer = STDIN.getc

    print "\n"

    if answer != "y"
      if STDIN.tty?
        pp(:info, "Installation not attempted.")
      else
        pp(:info, "Installation not attempted. If you are running this script non-interactively, consider providing" \
                  " the `-y` flag option.")
      end

      exit 1
    end
  end

  instance_exec(opts, user_opts, &OsX::Bootstrap.define_rake_tasks).invoke
end
